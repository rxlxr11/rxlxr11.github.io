[{"content":"Dao实现连接数据库 根据jdbc的基础知识可以看出，连接数据库的关键是要获取Connection对象，且数据库的连接数量存在限制，所以我们在一次连接中完成要做的业务后要关闭连接。为了提高代码的简洁性，复用性。我们要将获取connnection和关闭相关资源封装。\n根据以上信息我们可以创建一个IBaseDao接口，以后的dao都要继承IBaseDao\n1 2 3 4 public interface IBaseDao { Connection getConnection(); void close(ResultSet resultSet, Statement statement, Connection connection); } 实现IBaseDao接口 加载配置文件 将驱动，url，用户名，密码直接写在java代码中属于硬编码，为了让代码更加通用，我们将上述信息写在配置文件中，在java代码中我们只需要加载配置文件即可获取对应的信息。\n创建配置文件 在resources文件夹下创建jdbc.properties\n注意没有引号，在jdbc示例代码中copy过来时要注意\n1 2 3 4 driver = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT user = 用户名 password = 密码 类加载时加载配置文件 用静态代码块实现在类加载时获取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private static String driver; private static String url; private static String user; private static String password; static { try { //新建一个properties对象 Properties properties = new Properties(); //通过路径名获取配置文件输入流 InputStream resourceAsStream = BaseDaoImpl.class.getResourceAsStream(\u0026#34;/jdbc.properties\u0026#34;); //加载配置问价 properties.load(resourceAsStream); //根据关键字获取属性 driver = properties.getProperty(\u0026#34;driver\u0026#34;); url = properties.getProperty(\u0026#34;url\u0026#34;); user = properties.getProperty(\u0026#34;user\u0026#34;); password = properties.getProperty(\u0026#34;password\u0026#34;); //加载驱动 Class.forName(driver); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } } 实现getConnection方法 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public Connection getConnection() { Connection connection = null; try { connection = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return connection; } 实现close 应遵守先开的后关，后开先关的原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Override public void close(ResultSet resultSet, Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 根据表实现dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package yb.jsptest8.dao.impl; import yb.jsptest8.dao.IBaseDao; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class BaseDaoImpl implements IBaseDao { } ","date":"2025-02-19T00:00:00Z","permalink":"https://rxlxr11.github.io/zh-cn/p/ajax%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"ajax实现增删改查"},{"content":"CSS ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/css%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/cover_hu13272455037998876460.jpg","permalink":"https://rxlxr11.github.io/zh-cn/p/css%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/","title":"css基础应用"},{"content":"Dao实现连接数据库 根据jdbc的基础知识可以看出，连接数据库的关键是要获取Connection对象，且数据库的连接数量存在限制，所以我们在一次连接中完成要做的业务后要关闭连接。为了提高代码的简洁性，复用性。我们要将获取connnection和关闭相关资源封装。\n根据以上信息我们可以创建一个IBaseDao接口，以后的dao都要继承IBaseDao\n1 2 3 4 public interface IBaseDao { Connection getConnection(); void close(ResultSet resultSet, Statement statement, Connection connection); } 实现IBaseDao接口 加载配置文件 将驱动，url，用户名，密码直接写在java代码中属于硬编码，为了让代码更加通用，我们将上述信息写在配置文件中，在java代码中我们只需要加载配置文件即可获取对应的信息。\n创建配置文件 在resources文件夹下创建jdbc.properties\n注意没有引号，在jdbc示例代码中copy过来时要注意\n1 2 3 4 driver = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT user = 用户名 password = 密码 类加载时加载配置文件 用静态代码块实现在类加载时获取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private static String driver; private static String url; private static String user; private static String password; static { try { //新建一个properties对象 Properties properties = new Properties(); //通过路径名获取配置文件输入流 InputStream resourceAsStream = BaseDaoImpl.class.getResourceAsStream(\u0026#34;/jdbc.properties\u0026#34;); //加载配置问价 properties.load(resourceAsStream); //根据关键字获取属性 driver = properties.getProperty(\u0026#34;driver\u0026#34;); url = properties.getProperty(\u0026#34;url\u0026#34;); user = properties.getProperty(\u0026#34;user\u0026#34;); password = properties.getProperty(\u0026#34;password\u0026#34;); //加载驱动 Class.forName(driver); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } } 实现getConnection方法 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public Connection getConnection() { Connection connection = null; try { connection = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return connection; } 实现close 应遵守先开的后关，后开先关的原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Override public void close(ResultSet resultSet, Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 根据表实现dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package yb.jsptest8.dao.impl; import yb.jsptest8.dao.IBaseDao; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class BaseDaoImpl implements IBaseDao { } ","date":"2025-02-19T00:00:00Z","permalink":"https://rxlxr11.github.io/zh-cn/p/hugo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/","title":"hugo博客创建"},{"content":"Java Database Connectivity 概念 JAVA数据库连接技术\n主要功能 1.与数据库建立连接、执行SQL语句、处理结果\n相关对象功能 DriverManager: 管理JDBC驱动\nConnection: 负责数据库连接并传送数据任务\nStatement: 负责执行SQL语句\nResultSet: 负责保存结果（结果集）\n操作步骤 加载JDBC驱动 1 Class.forName(........); 建立与数据库连接 1 2 Connection con=DriverManager.getConnection(URL,数据库用户名,密码); \u0026#34;jdbc:mysql://localhost:3306/world?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone = GMT\u0026#34;,\u0026#34;xxxx\u0026#34;,\u0026#34;xxxx\u0026#34; 发送SQL语句得到结果集 1 2 Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(String sql); 释放资源 1 2 3 rs.close(); stmt.close(); con.close(); Statement常用方法 1 2 3 4 ResultSet executeQuery(String sql)//执行sql查询并获得结果集 int executeUpdate(String sql)//可以执行插入、删除、更新等操作，返回的是执行操作影响的行数 boolean execute(String sql)//执行任意sql语句，获得一个布尔值，表示是否返回ResultSet void close()//关闭 ResultSet 1 2 3 4 5 6 7 8 9 boolean next()//将游标从当前位置向下移动一行 boolean previous()//游标从当前位置向上移动一行 void close()//关闭ResultSet 对象 int getInt(int colIndex)//以int形式获取结果集当前行指定列号值 int getInt(String colLabel)//以int形式获取结果集当前行指定列名值 float getFloat(int colIndex)//以float形式获取结果集当前行指定列号值 float getFloat(String colLabel)//以float形式获取结果集当前行指定列名值 String getString(int colIndex)//以String 形式获取结果集当前行指定列号值 String getString(String colLabel)//以String形式获取结果集当前行指定列名值 PreparedStatement 优点 1.提高代码的可读性与可维护性\n2.提高sql语句的执行性能\n3.提高了安全性\n举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt = null; conn = DriverManager.getConnection( \u0026#34;jdbc:mysql://localhost:3306/epet\u0026#34;, \u0026#34;epetadmin\u0026#34;, \u0026#34;0000\u0026#34;); // 3、更新狗狗信息到数据库 String sql=\u0026#34;update dog set health=?,love=? where id=?\u0026#34;; pstmt = conn.prepareStatement(sql); pstmt.setInt(1, 80); pstmt.setInt(2, 15); pstmt.setInt(3, 1); pstmt.executeUpdate(); pstmt.setInt(1, 90); pstmt.setInt(2, 10); pstmt.setInt(3, 2); pstmt.executeUpdate(); logger.info(\u0026#34;成功更新狗狗信息！\u0026#34;); } catch (SQLException e) {\tlogger.error(e); } finally { // 4、关闭Statement和数据库连接 try { if (null != pstmt) { pstmt.close(); } if (null != conn) { conn.close(); } } catch (SQLException e) { logger.error(e); } } } ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/jdbc/cover_hu10934689398732408489.jpg","permalink":"https://rxlxr11.github.io/zh-cn/p/jdbc/","title":"JDBC"},{"content":"Dao实现连接数据库 根据jdbc的基础知识可以看出，连接数据库的关键是要获取Connection对象，且数据库的连接数量存在限制，所以我们在一次连接中完成要做的业务后要关闭连接。为了提高代码的简洁性，复用性。我们要将获取connnection和关闭相关资源封装。\n根据以上信息我们可以创建一个IBaseDao接口，以后的dao都要继承IBaseDao\n1 2 3 4 public interface IBaseDao { Connection getConnection(); void close(ResultSet resultSet, Statement statement, Connection connection); } 实现IBaseDao接口 加载配置文件 将驱动，url，用户名，密码直接写在java代码中属于硬编码，为了让代码更加通用，我们将上述信息写在配置文件中，在java代码中我们只需要加载配置文件即可获取对应的信息。\n创建配置文件 在resources文件夹下创建jdbc.properties\n注意没有引号，在jdbc示例代码中copy过来时要注意\n1 2 3 4 driver = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT user = 用户名 password = 密码 类加载时加载配置文件 用静态代码块实现在类加载时获取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private static String driver; private static String url; private static String user; private static String password; static { try { //新建一个properties对象 Properties properties = new Properties(); //通过路径名获取配置文件输入流 InputStream resourceAsStream = BaseDaoImpl.class.getResourceAsStream(\u0026#34;/jdbc.properties\u0026#34;); //加载配置问价 properties.load(resourceAsStream); //根据关键字获取属性 driver = properties.getProperty(\u0026#34;driver\u0026#34;); url = properties.getProperty(\u0026#34;url\u0026#34;); user = properties.getProperty(\u0026#34;user\u0026#34;); password = properties.getProperty(\u0026#34;password\u0026#34;); //加载驱动 Class.forName(driver); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } } 实现getConnection方法 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public Connection getConnection() { Connection connection = null; try { connection = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return connection; } 实现close 应遵守先开的后关，后开先关的原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Override public void close(ResultSet resultSet, Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 根据表实现dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package yb.jsptest8.dao.impl; import yb.jsptest8.dao.IBaseDao; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class BaseDaoImpl implements IBaseDao { } ","date":"2025-02-19T00:00:00Z","permalink":"https://rxlxr11.github.io/zh-cn/p/jsp%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"jsp实现增删改查"},{"content":"Dao实现连接数据库 根据jdbc的基础知识可以看出，连接数据库的关键是要获取Connection对象，且数据库的连接数量存在限制，所以我们在一次连接中完成要做的业务后要关闭连接。为了提高代码的简洁性，复用性。我们要将获取connnection和关闭相关资源封装。\n根据以上信息我们可以创建一个IBaseDao接口，以后的dao都要继承IBaseDao\n1 2 3 4 public interface IBaseDao { Connection getConnection(); void close(ResultSet resultSet, Statement statement, Connection connection); } 实现IBaseDao接口 加载配置文件 将驱动，url，用户名，密码直接写在java代码中属于硬编码，为了让代码更加通用，我们将上述信息写在配置文件中，在java代码中我们只需要加载配置文件即可获取对应的信息。\n创建配置文件 在resources文件夹下创建jdbc.properties\n注意没有引号，在jdbc示例代码中copy过来时要注意\n1 2 3 4 driver = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT user = 用户名 password = 密码 类加载时加载配置文件 用静态代码块实现在类加载时获取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private static String driver; private static String url; private static String user; private static String password; static { try { //新建一个properties对象 Properties properties = new Properties(); //通过路径名获取配置文件输入流 InputStream resourceAsStream = BaseDaoImpl.class.getResourceAsStream(\u0026#34;/jdbc.properties\u0026#34;); //加载配置问价 properties.load(resourceAsStream); //根据关键字获取属性 driver = properties.getProperty(\u0026#34;driver\u0026#34;); url = properties.getProperty(\u0026#34;url\u0026#34;); user = properties.getProperty(\u0026#34;user\u0026#34;); password = properties.getProperty(\u0026#34;password\u0026#34;); //加载驱动 Class.forName(driver); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } } 实现getConnection方法 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public Connection getConnection() { Connection connection = null; try { connection = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return connection; } 实现close 应遵守先开的后关，后开先关的原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Override public void close(ResultSet resultSet, Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 根据表实现dao 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package yb.jsptest8.dao.impl; import yb.jsptest8.dao.IBaseDao; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class BaseDaoImpl implements IBaseDao { } ","date":"2025-02-19T00:00:00Z","permalink":"https://rxlxr11.github.io/zh-cn/p/js%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/","title":"js实现轮播图"},{"content":"DAO实现连接数据库 根据jdbc的基础知识可以看出，连接数据库的关键是要获取Connection对象，且数据库的连接数量存在限制，所以我们在一次连接中完成要做的业务后要关闭连接。为了提高代码的简洁性，复用性。我们要将获取connnection和关闭相关资源封装。\n根据以上信息我们可以创建一个IBaseDao接口，以后的dao都要继承IBaseDao\n1 2 3 4 public interface IBaseDao { Connection getConnection(); void close(ResultSet resultSet, Statement statement, Connection connection); } 实现IBaseDao接口 加载配置文件 将驱动，url，用户名，密码直接写在java代码中属于硬编码，为了让代码更加通用，我们将上述信息写在配置文件中，在java代码中我们只需要加载配置文件即可获取对应的信息。\n创建配置文件 在resources文件夹下创建jdbc.properties\n注意没有引号，在jdbc示例代码中copy过来时要注意\n1 2 3 4 driver = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT user = 用户名 password = 密码 类加载时加载配置文件 用静态代码块实现在类加载时获取配置信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private static String driver; private static String url; private static String user; private static String password; static { try { //新建一个properties对象 Properties properties = new Properties(); //通过路径名获取配置文件输入流 InputStream resourceAsStream = BaseDaoImpl.class.getResourceAsStream(\u0026#34;/jdbc.properties\u0026#34;); //加载配置问价 properties.load(resourceAsStream); //根据关键字获取属性 driver = properties.getProperty(\u0026#34;driver\u0026#34;); url = properties.getProperty(\u0026#34;url\u0026#34;); user = properties.getProperty(\u0026#34;user\u0026#34;); password = properties.getProperty(\u0026#34;password\u0026#34;); //加载驱动 Class.forName(driver); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } } 实现getConnection方法 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public Connection getConnection() { Connection connection = null; try { connection = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return connection; } 实现close 应遵守先开的后关，后开先关的原则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Override public void close(ResultSet resultSet, Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 根据表实现DAO 有以下表\n字段名 数据类型 约束条件 说明 student_id int NOT NULL AUTO_INCREMENT PRIMARY KEY 学生ID student_name varchar(255) DEFAULT NULL 学生姓名 student_age int DEFAULT NULL 学生年龄 student_gender int DEFAULT NULL 学生性别（可能使用 0/1 表示） student_idcard varchar(255) DEFAULT NULL 学生身份证号 student_num varchar(255) DEFAULT NULL 学生学号 student_phone varchar(255) DEFAULT NULL 学生电话 class_id int DEFAULT NULL 班级ID，外键关联班级表 实体类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 public class Student { private Integer studentId; private String studentName; private Integer age; private Integer gender; private String studentIdcard; private String studentNum; private String studentPhone; public Student(Integer studentId, String studentName, Integer age, Integer gender, String studentIdcard, String studentNum, String studentPhone) { this.studentId = studentId; this.studentName = studentName; this.age = age; this.gender = gender; this.studentIdcard = studentIdcard; this.studentNum = studentNum; this.studentPhone = studentPhone; } public Student() { } public Integer getStudentId() { return studentId; } public void setStudentId(Integer studentId) { this.studentId = studentId; } public String getStudentName() { return studentName; } public void setStudentName(String studentName) { this.studentName = studentName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public String getStudentIdcard() { return studentIdcard; } public void setStudentIdcard(String studentIdcard) { this.studentIdcard = studentIdcard; } public String getStudentNum() { return studentNum; } public void setStudentNum(String studentNum) { this.studentNum = studentNum; } public String getStudentPhone() { return studentPhone; } public void setStudentPhone(String studentPhone) { this.studentPhone = studentPhone; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return Objects.equals(studentId, student.studentId) \u0026amp;\u0026amp; Objects.equals(studentName, student.studentName) \u0026amp;\u0026amp; Objects.equals(age, student.age) \u0026amp;\u0026amp; Objects.equals(gender, student.gender) \u0026amp;\u0026amp; Objects.equals(studentIdcard, student.studentIdcard) \u0026amp;\u0026amp; Objects.equals(studentNum, student.studentNum) \u0026amp;\u0026amp; Objects.equals(studentPhone, student.studentPhone); } @Override public int hashCode() { return Objects.hash(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone); } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;studentId=\u0026#34; + studentId + \u0026#34;, studentName=\u0026#39;\u0026#34; + studentName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, studentIdcard=\u0026#39;\u0026#34; + studentIdcard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, studentNum=\u0026#39;\u0026#34; + studentNum + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, studentPhone=\u0026#39;\u0026#34; + studentPhone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 新建接口 1 2 3 public interface IStudentDao extends IBaseDao { ArrayList\u0026lt;Student\u0026gt; queryAll(); } 实现接口 继承BaseDao并实现IStudentDao\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class StudentDaoImpl extends BaseDaoImpl implements IStudentDao { @Override public ArrayList\u0026lt;Student\u0026gt; queryAll() { //建立数据库连接 Connection con = getConnection(); PreparedStatement statement = null; ResultSet resultSet=null; ArrayList\u0026lt;Student\u0026gt; students=null; try { //执行sql语句并返回结果 statement = con.prepareStatement(\u0026#34;select * from student\u0026#34;); resultSet = statement.executeQuery(); students= new ArrayList\u0026lt;\u0026gt;(); //通过集合将结果集映射到集合 while (resultSet.next()){ String studentName = resultSet.getString(\u0026#34;student_name\u0026#34;); Integer studentId = resultSet.getInt(\u0026#34;student_id\u0026#34;); Integer age = resultSet.getInt(\u0026#34;student_age\u0026#34;); Integer gender = resultSet.getInt(\u0026#34;student_gender\u0026#34;); String studentIdcard = resultSet.getString(\u0026#34;student_idcard\u0026#34;); String studentNum = resultSet.getString(\u0026#34;student_num\u0026#34;); String studentPhone = resultSet.getString(\u0026#34;student_phone\u0026#34;); Student student = new Student(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone); students.add(student); } } catch (SQLException e) { e.printStackTrace(); }finally { close(resultSet,statement,con); } return students; } } 测试 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 main └── java └── com.rxlxr ├── dao │ ├── impl │ │ ├── BaseDaoImpl │ │ └── StudentDaoImpl │ ├── IBaseDao │ └── IStudentDao ├── pojo │ └── Student └── Test └── resources └── jdbc.properties 测试代码 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { StudentDaoImpl studentDao = new StudentDaoImpl(); ArrayList\u0026lt;Student\u0026gt; students = studentDao.queryAll(); System.out.println(students); } } 测试结果 1 [Student{studentId=1, studentName=\u0026#39;aa\u0026#39;, age=11, gender=11, studentIdcard=\u0026#39;11\u0026#39;, studentNum=\u0026#39;11\u0026#39;, studentPhone=\u0026#39;11\u0026#39;}] ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0dao/cover_hu2153556584596572680.jpg","permalink":"https://rxlxr11.github.io/zh-cn/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0dao/","title":"用JDBC实现DAO"},{"content":"增删改查 基于用jdbc实现DAO，在对应实体类的DAO中，增加相应声明。\n1 2 3 4 5 6 7 8 public interface IStudentDao extends IBaseDao { ArrayList\u0026lt;Student\u0026gt; queryAll(); Integer addOne(Student student); Integer updateById(Student student); Integer deleteById(Integer studentId); Student queryById(Integer id); ArrayList\u0026lt;Student\u0026gt; queryByCondition(Student student); } 增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Override public Integer addOne(Student student) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { //写要执行的sql语句 statement = con.prepareStatement(\u0026#34;insert into student values (default,?,?,?,?,?,?)\u0026#34;); //根据下标设置参数，下标从1开始 statement.setString(1,student.getStudentName()); statement.setInt(2,student.getAge()); statement.setInt(3,student.getGender()); statement.setString(4,student.getStudentIdcard()); statement.setString(5,student.getStudentNum()); statement.setString(6,student.getStudentPhone()); //返回修改了几条记录 i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 删 删和改一定要有where\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public Integer deleteById(Integer studentId) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { statement = con.prepareStatement(\u0026#34;delete from student where student_id=?\u0026#34;); statement.setInt(1,studentId); i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Override public Integer updateById(Student student) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { statement = con.prepareStatement(\u0026#34;update student set student_name=?,student_age=?,student_gender=?,student_idcard=?,student_num=?,student_phone=? where student_id = ?\u0026#34; ); statement.setString(1,student.getStudentName()); statement.setInt(2,student.getAge()); statement.setInt(3,student.getGender()); statement.setString(4,student.getStudentIdcard()); statement.setString(5,student.getStudentNum()); statement.setString(6,student.getStudentPhone()); statement.setInt(7,student.getStudentId()); i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @Override public ArrayList\u0026lt;Student\u0026gt; queryByCondition(Student student) { Connection connection = getConnection(); PreparedStatement statement = null; ResultSet resultSet = null; ArrayList\u0026lt;Student\u0026gt; students = null; // 用于存储下标和？的值 ArrayList\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); try { students = new ArrayList\u0026lt;\u0026gt;(); StringBuilder stringBuilder = new StringBuilder(); String sql = \u0026#34;select * from student\u0026#34;; boolean flag = false; if (student.getStudentName() != null) { flag = true; objects.add(student.getStudentName()); stringBuilder.append(\u0026#34; student_name=? and\u0026#34;); } if (student.getAge() != null) { flag = true; objects.add(student.getAge()); stringBuilder.append(\u0026#34; student_age=? and\u0026#34;); } if (student.getGender() != null) { flag = true; objects.add(student.getGender()); stringBuilder.append(\u0026#34; student_gender=? and\u0026#34;); } if (student.getStudentIdcard() != null) { flag = true; objects.add(student.getStudentIdcard()); stringBuilder.append(\u0026#34; student_idcard=? and\u0026#34;); } if (student.getStudentNum() != null) { flag = true; objects.add(student.getStudentNum()); stringBuilder.append(\u0026#34; student_num=? and\u0026#34;); } if (student.getStudentPhone() != null) { flag = true; objects.add(student.getStudentPhone()); stringBuilder.append(\u0026#34; student_phone=? and\u0026#34;); } String string = stringBuilder.toString(); String substring=\u0026#34;\u0026#34;; String whereStr = \u0026#34;\u0026#34;; if (flag){ string = string.substring(0,string.length()-3); whereStr = \u0026#34; where \u0026#34;; } sql = flag ? sql+whereStr+string : sql; statement = connection.prepareStatement(sql); for (int i = 0; i \u0026lt; objects.size(); i++) { statement.setObject(i+1,objects.get(i)); } resultSet = statement.executeQuery(); while (resultSet.next()){ String studentName = resultSet.getString(\u0026#34;student_name\u0026#34;); Integer studentId = resultSet.getInt(\u0026#34;student_id\u0026#34;); Integer age = resultSet.getInt(\u0026#34;student_age\u0026#34;); Integer gender = resultSet.getInt(\u0026#34;student_gender\u0026#34;); String studentIdcard = resultSet.getString(\u0026#34;student_idcard\u0026#34;); String studentNum = resultSet.getString(\u0026#34;student_num\u0026#34;); String studentPhone = resultSet.getString(\u0026#34;student_phone\u0026#34;); students.add(new Student(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone)); } } catch (SQLException e) { e.printStackTrace(); } finally { close(resultSet,statement,connection); } return students; } ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/cover_hu2153556584596572680.jpg","permalink":"https://rxlxr11.github.io/zh-cn/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"用JDBC实现增删改查"},{"content":"增删改查 基于用jdbc实现DAO，在对应实体类的DAO中，增加相应声明。\n1 2 3 4 5 6 7 8 public interface IStudentDao extends IBaseDao { ArrayList\u0026lt;Student\u0026gt; queryAll(); Integer addOne(Student student); Integer updateById(Student student); Integer deleteById(Integer studentId); Student queryById(Integer id); ArrayList\u0026lt;Student\u0026gt; queryByCondition(Student student); } 增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Override public Integer addOne(Student student) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { //写要执行的sql语句 statement = con.prepareStatement(\u0026#34;insert into student values (default,?,?,?,?,?,?)\u0026#34;); //根据下标设置参数，下标从1开始 statement.setString(1,student.getStudentName()); statement.setInt(2,student.getAge()); statement.setInt(3,student.getGender()); statement.setString(4,student.getStudentIdcard()); statement.setString(5,student.getStudentNum()); statement.setString(6,student.getStudentPhone()); //返回修改了几条记录 i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 删 删和改一定要有where\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public Integer deleteById(Integer studentId) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { statement = con.prepareStatement(\u0026#34;delete from student where student_id=?\u0026#34;); statement.setInt(1,studentId); i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Override public Integer updateById(Student student) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { statement = con.prepareStatement(\u0026#34;update student set student_name=?,student_age=?,student_gender=?,student_idcard=?,student_num=?,student_phone=? where student_id = ?\u0026#34; ); statement.setString(1,student.getStudentName()); statement.setInt(2,student.getAge()); statement.setInt(3,student.getGender()); statement.setString(4,student.getStudentIdcard()); statement.setString(5,student.getStudentNum()); statement.setString(6,student.getStudentPhone()); statement.setInt(7,student.getStudentId()); i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @Override public ArrayList\u0026lt;Student\u0026gt; queryByCondition(Student student) { Connection connection = getConnection(); PreparedStatement statement = null; ResultSet resultSet = null; ArrayList\u0026lt;Student\u0026gt; students = null; // 用于存储下标和？的值 ArrayList\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); try { students = new ArrayList\u0026lt;\u0026gt;(); StringBuilder stringBuilder = new StringBuilder(); String sql = \u0026#34;select * from student\u0026#34;; boolean flag = false; if (student.getStudentName() != null) { flag = true; objects.add(student.getStudentName()); stringBuilder.append(\u0026#34; student_name=? and\u0026#34;); } if (student.getAge() != null) { flag = true; objects.add(student.getAge()); stringBuilder.append(\u0026#34; student_age=? and\u0026#34;); } if (student.getGender() != null) { flag = true; objects.add(student.getGender()); stringBuilder.append(\u0026#34; student_gender=? and\u0026#34;); } if (student.getStudentIdcard() != null) { flag = true; objects.add(student.getStudentIdcard()); stringBuilder.append(\u0026#34; student_idcard=? and\u0026#34;); } if (student.getStudentNum() != null) { flag = true; objects.add(student.getStudentNum()); stringBuilder.append(\u0026#34; student_num=? and\u0026#34;); } if (student.getStudentPhone() != null) { flag = true; objects.add(student.getStudentPhone()); stringBuilder.append(\u0026#34; student_phone=? and\u0026#34;); } String string = stringBuilder.toString(); String substring=\u0026#34;\u0026#34;; String whereStr = \u0026#34;\u0026#34;; if (flag){ string = string.substring(0,string.length()-3); whereStr = \u0026#34; where \u0026#34;; } sql = flag ? sql+whereStr+string : sql; statement = connection.prepareStatement(sql); for (int i = 0; i \u0026lt; objects.size(); i++) { statement.setObject(i+1,objects.get(i)); } resultSet = statement.executeQuery(); while (resultSet.next()){ String studentName = resultSet.getString(\u0026#34;student_name\u0026#34;); Integer studentId = resultSet.getInt(\u0026#34;student_id\u0026#34;); Integer age = resultSet.getInt(\u0026#34;student_age\u0026#34;); Integer gender = resultSet.getInt(\u0026#34;student_gender\u0026#34;); String studentIdcard = resultSet.getString(\u0026#34;student_idcard\u0026#34;); String studentNum = resultSet.getString(\u0026#34;student_num\u0026#34;); String studentPhone = resultSet.getString(\u0026#34;student_phone\u0026#34;); students.add(new Student(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone)); } } catch (SQLException e) { e.printStackTrace(); } finally { close(resultSet,statement,connection); } return students; } ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/cover_hu2153556584596572680.jpg","permalink":"https://rxlxr11.github.io/zh-cn/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"用JDBC实现增删改查"}]
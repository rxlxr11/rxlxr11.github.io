[{"content":"数据集 若能找到公开数据集，该章操作都可以省略，否则按照以下步骤创建数据集\n运行环境 安装Anaconda\nAnaconda 是一个专为数据科学、机器学习和大数据处理设计的开源 Python/R 发行版本和管理平台。它由 Anaconda, Inc.（原 Continuum Analytics）开发，旨在简化数据科学项目中常见的环境配置、包管理和依赖冲突等问题。\n使用Anaconda-Navigator，用图形化界面创建python 3.8（mac环境下高版本可能会有报错，所以尽量使用3.8）的环境\n安装LabelImg git clone https://github.com/HumanSignal/labelImg.git cd labelImg conda activate [环境名] pip3 install pyqt5 lxml make qt5py3 python3 labelImg.py 手动标注 在图形化界面打开图片目录，选择格式为yolo。\n建議記下常用快捷鍵較方便，上一張按A，下一張按D，儲存按Ctrl+S，創建新的標記框按W，刪除錯誤框Del 。\n按下w框初目标并保存。\n目录结构 每张图片在 images/ 里，每个对应的 .txt 标注文件在 labels/ 里。\nyanhe/ ├── dataset/ │ ├── images/ │ │ ├── train/ │ │ └── val/ │ ├── labels/ │ │ ├── train/ │ │ └── val/ │ └── data.yaml 配置文件 data.yaml 内容如下\ntrain: ../dataset/images/train val: ../dataset/images/val nc: 3 # 类别数量 names: [\u0026#39;南京\u0026#39;,\u0026#39;中华\u0026#39;,\u0026#39;中南海\u0026#39;] # 类别名称 Yolov5 运行环境 使用Anaconda-Navigator，用图形化界面创建python 3.10的环境\n安装yolov5 cd [工程文件名] # 克隆 YOLOv5 git clone https://github.com/ultralytics/yolov5.git cd yolov5 conda activate [环境名] pip install -r requirements.txt 训练模型 cd ~/Desktop/code/yan/yanhe/yolov5 python train.py --img 640 --batch 4 --epochs 50 --data ../dataset/data.yaml --weights yolov5s.pt 执行完后会有以下提示\nResults saved to yolov5/runs/train/exp5 使用模型 import torch import cv2 from PIL import Image, ImageDraw, ImageFont import numpy as np # 加载模型 model = torch.hub.load(\u0026#39;yolov5\u0026#39;, \u0026#39;custom\u0026#39;, path=\u0026#39;yolov5/runs/train/exp7/weights/best.pt\u0026#39;, source=\u0026#39;local\u0026#39;) model.conf = 0.2 model.iou = 0.45 model.classes = None img_path = \u0026#39;test.jpg\u0026#39; img_bgr = cv2.imread(img_path) # 推理 results = model(img_bgr) detections = results.pandas().xyxy[0] # OpenCV 图像转换为 PIL 图像（RGB） img_pil = Image.fromarray(cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)) draw = ImageDraw.Draw(img_pil) # 加载支持中文的字体（确保路径正确） font_path = \u0026#34;/System/Library/Fonts/STHeiti Light.ttc\u0026#34; # macOS 自带中文字体路径之一 font = ImageFont.truetype(font_path, 20) print(f\u0026#39;识别到 {len(detections)} 个物体。\u0026#39;) for _, row in detections.iterrows(): xmin, ymin, xmax, ymax = int(row[\u0026#39;xmin\u0026#39;]), int(row[\u0026#39;ymin\u0026#39;]), int(row[\u0026#39;xmax\u0026#39;]), int(row[\u0026#39;ymax\u0026#39;]) confidence, name = row[\u0026#39;confidence\u0026#39;], row[\u0026#39;name\u0026#39;] label = f\u0026#39;{name} {confidence:.2f}\u0026#39; # 画边框 draw.rectangle([(xmin, ymin), (xmax, ymax)], outline=\u0026#39;green\u0026#39;, width=2) # 画文字背景和文字 bbox = draw.textbbox((xmin, ymin), label, font=font) text_width = bbox[2] - bbox[0] text_height = bbox[3] - bbox[1] draw.rectangle([xmin, ymin - text_height, xmin + text_width, ymin], fill=\u0026#39;green\u0026#39;) draw.text((xmin, ymin - text_height), label, font=font, fill=\u0026#39;black\u0026#39;) # 转换回 OpenCV 图像并保存 img_result = cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR) output_path = \u0026#39;inference_results/test_with_boxes.jpg\u0026#39; cv2.imwrite(output_path, img_result) print(f\u0026#39;结果已保存至 {output_path}\u0026#39;) ","date":"2025-06-23T00:00:00Z","image":"https://rxlxr11.github.io/p/yolov5%E4%BD%BF%E7%94%A8/cover_hu10460112045981832539.webp","permalink":"https://rxlxr11.github.io/p/yolov5%E4%BD%BF%E7%94%A8/","title":"YOLOv5使用"},{"content":"vscode 格式化 shift+option+f MAC 隐藏文件 cmd+shift+. 关闭所有视窗 opt+cmd+w IDEA 替换 cmd+r 格式化代码 opt+cmd+l ","date":"2025-06-01T00:00:00Z","permalink":"https://rxlxr11.github.io/p/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"常用快捷键"},{"content":"Day1 酒店 ——\u0026gt; 船歌·鱼水饺青岛菜 ——\u0026gt; 圣弥厄尔教堂 ——\u0026gt; 栈桥景区 ——\u0026gt; 信号山公园 ——\u0026gt; 台东步行街 ——\u0026gt; 桥底野馄炖\n如家酒店还是可以的价格便宜，设别齐全，房间整洁无异味。收拾完要2点了，出发吃午饭。\n\u0026hellip; \u0026hellip;\n船歌纯纯网红店，菜味道一般但是贵，还好有免费小零食，续了大概四五盘+尝了崂山可乐，还不错，有股药草香。\n在船歌没吃饱在周围找了家海鲜馄炖，有点吃不惯这种搭配感觉很腥。\n从大鲍岛步行至圣弥厄尔教堂，打卡点，有很多人在拍照，进去转了一圈 5r。\n步行至栈桥，第一次见到沙滩，但是这的沙滩有点袖珍，且没穿拖鞋，没能好好体验。\n下一站信号山公园，途中买了白花蛇草水，微苦。信号山不高，算是个小土丘，没多久就登顶了。\n\u0026hellip; \u0026hellip;\n晚饭时间，去步行街尝别人推荐的排骨饭，明明还没到5.1假期，步行街依旧人潮涌动，跟着导航找到了排骨饭，但是未达预期。不过没关系，步行街难道还缺吃的吗，买了皮皮虾，海胆，又找了家烧烤吃生蚝等。\n最后一站桥底野馄炖，这里很多夜宵店铺貌似都叫野馄炖。\nDay2 酒店 ——\u0026gt; 第二海水浴场 ——\u0026gt; 太平角公园旁的一家饭店 ——\u0026gt; 五四广场 ——\u0026gt; 海岸线暴走 ——\u0026gt; 小麦岛 ——\u0026gt; 晓川香木桶鱼\n第一天玩的很匆忙，第二天终于可以用力的感受青岛的气息了。 第一站第二海水浴场，昨天的沙滩与海水浴场的沙滩相比完全是大巫见小巫。一早过去，阳光明媚，踩在沙子上暖暖的。卷起裤脚，向大海前进。 临近中午，在司机师傅的推荐下去了浴场旁的一家饭店，点了些海鲜。 吃完饭分为两组，我和老八从太平角公园坐地铁至五四广场，随后开始海岸线暴走。 差点走至小麦岛，最后一公里，坚持不住了，打车到小麦岛，汇合看落日。 晚饭吃川菜，有亿点点辣\u0026hellip; Day3 酒店 ——\u0026gt; 福多多家常菜 ——\u0026gt; 啤酒博物馆 ——\u0026gt; 石老人海水浴场\nDay4 酒店 ——\u0026gt; 海底世界 ——\u0026gt; 烤串 ——\u0026gt; 青岛北 ——\u0026gt; 威海站 ——\u0026gt; 火炬八街\nDay5 韩乐坊 ——\u0026gt; 布鲁威斯号 ——\u0026gt; 刘公岛 ——\u0026gt; 吴草鸡爪 ——\u0026gt; 猫头山\n","date":"2025-04-30T00:00:00Z","image":"https://rxlxr11.github.io/p/%E9%9D%92%E5%B2%9B%E5%A8%81%E6%B5%B7/cover_hu2767561184545030147.png","permalink":"https://rxlxr11.github.io/p/%E9%9D%92%E5%B2%9B%E5%A8%81%E6%B5%B7/","title":"青岛威海"},{"content":"","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/ajax/cover_hu3964810419771531244.jpg","permalink":"https://rxlxr11.github.io/p/ajax/","title":"ajax"},{"content":"申请密匙 展示地图 关于新建地图的代码在高德官方文档中写得比较详尽，此处就不再赘述。\n高德文档\n进入页面看到地图，就可以算是完成使用amap的伟大的第一步了。\n展示图层 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;map-container\u0026#34; style=\u0026#34;width: 100%; height: 80vh;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;hideLayer\u0026#34;\u0026gt;隐藏图层\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showLayer\u0026#34;\u0026gt;展示图层\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;addLayer\u0026#34;\u0026gt;添加图层\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;removeLayer\u0026#34;\u0026gt;移除图层\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import AMapLoader from \u0026#39;@amap/amap-jsapi-loader\u0026#39;; import { onMounted, onUnmounted } from \u0026#39;vue\u0026#39;; let map = null; let traffic = null; const showLayer = () =\u0026gt; { if (map.hasLayer(traffic)) { console.warn(\u0026#34;Traffic layer is already visible.\u0026#34;); return; } traffic.show(); // 显示图层 } const hideLayer = () =\u0026gt; { if (!map.hasLayer(traffic)) { console.warn(\u0026#34;Traffic layer is not visible.\u0026#34;); return; } traffic.hide(); // 隐藏图层 } const addLayer = () =\u0026gt; { if (map.hasLayer(traffic)) { console.warn(\u0026#34;Traffic layer is already added.\u0026#34;); return; } map.add(traffic); // 通过add方法添加图层 } const removeLayer = () =\u0026gt; { if (!map.hasLayer(traffic)) { console.warn(\u0026#34;Traffic layer is not added.\u0026#34;); return; } map.remove(traffic); // 通过remove方法移除图层 } onMounted(() =\u0026gt; { AMapLoader.load({ key: \u0026#34;\u0026#34;, // 申请好的Web端开发者Key，首次调用 load 时必填 version: \u0026#34;2.0\u0026#34;, // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: [\u0026#34;AMap.Scale\u0026#34;], //需要使用的的插件列表，如比例尺\u0026#39;AMap.Scale\u0026#39;，支持添加多个如：[\u0026#39;...\u0026#39;,\u0026#39;...\u0026#39;] }) .then((AMap) =\u0026gt; { const defaultLayer = new AMap.createDefaultLayer({ zooms: [3, 20], //可见级别 visible: true, //是否可见 opacity: 1, //透明度 zIndex: 0, //叠加层级 }); const roadNetLayer = new AMap.TileLayer.RoadNet({ zIndex: 1 }); map = new AMap.Map(\u0026#34;map-container\u0026#34;, { // 设置地图容器id viewMode: \u0026#34;2D\u0026#34;, // 是否为3D地图模式 zoom: 11, // 初始化地图级别 center: [116.397428, 39.90923], // 初始化地图中心点位置 layers: [defaultLayer, roadNetLayer], //layer为创建的默认图层 }); traffic = new AMap.TileLayer.Traffic({ autoRefresh: true, //是否自动刷新，默认为false interval: 180, //刷新间隔，默认180s }); map.add(traffic); //通过add方法添加图层 }) .catch((e) =\u0026gt; { console.log(e); }); }); onUnmounted(() =\u0026gt; { map?.destroy(); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 添加地图控件 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;map-container\u0026#34; style=\u0026#34;width: 100%; height: 80vh;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;input-card\u0026#39;\u0026gt; \u0026lt;div class=\u0026#34;input-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; @click=\u0026#34;toggleScale\u0026#34; /\u0026gt;比例尺 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;toolbar\u0026#34; @click=\u0026#34;toggleToolBar\u0026#34; /\u0026gt;工具条 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;controlBar\u0026#34; @click=\u0026#34;toggleControlBar\u0026#34; /\u0026gt;工具条方向盘 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;overview\u0026#34; @click=\u0026#34;toggleOverViewShow\u0026#34; /\u0026gt;显示鹰眼 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import AMapLoader from \u0026#39;@amap/amap-jsapi-loader\u0026#39;; import { onMounted, onUnmounted } from \u0026#39;vue\u0026#39;; let map = null; let overView = null; let toolbar = null; let controlBar = null; let scale = null; const toggleOverViewShow = (event) =\u0026gt; { var checked = event.target.checked; if (checked) { overView.show(); } else { overView.hide(); } } const toggleControlBar = (event) =\u0026gt; { var checked = event.target.checked; if (checked) { controlBar.show(); } else { controlBar.hide(); } } const toggleScale = (event) =\u0026gt; { var checked = event.target.checked; if (checked) { scale.show(); } else { scale.hide(); } } const toggleToolBar = (event) =\u0026gt; { var checked = event.target.checked; if (checked) { toolbar.show(); } else { toolbar.hide(); } } onMounted(() =\u0026gt; { AMapLoader.load({ key: \u0026#34;\u0026#34;, // 申请好的Web端开发者Key，首次调用 load 时必填 version: \u0026#34;2.0\u0026#34;, // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: [\u0026#39;AMap.ToolBar\u0026#39;, \u0026#39;AMap.ControlBar\u0026#39;, \u0026#39;AMap.Scale\u0026#39;, \u0026#39;AMap.HawkEye\u0026#39;] //加载插件, }) .then((AMap) =\u0026gt; { map = new AMap.Map(\u0026#34;map-container\u0026#34;, { // 设置地图容器id viewMode: \u0026#34;2D\u0026#34;, // 是否为3D地图模式 zoom: 11, // 初始化地图级别 center: [116.397428, 39.90923], // 初始化地图中心点位置 }); toolbar = new AMap.ToolBar(); controlBar = new AMap.ControlBar(); scale = new AMap.Scale(); overView = new AMap.HawkEye(); map.addControl(toolbar); map.addControl(controlBar); map.addControl(scale); map.addControl(overView); }) .catch((e) =\u0026gt; { console.log(e); }); }); onUnmounted(() =\u0026gt; { map?.destroy(); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; html, body { height: 100%; } #container { height: 100%; } .input-card { width: 150px; top: 10px; left: 10px; bottom: auto; } \u0026lt;/style\u0026gt; 添加点标记 添加多边形 ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/amap%E4%BD%BF%E7%94%A8/cover_hu6614375119765245372.jpg","permalink":"https://rxlxr11.github.io/p/amap%E4%BD%BF%E7%94%A8/","title":"AMap使用"},{"content":"CSS ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/css%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/cover_hu13272455037998876460.jpg","permalink":"https://rxlxr11.github.io/p/css%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/","title":"css基础应用"},{"content":"认识Docker 借助 Docker，可将容器当做轻巧、模块化的虚拟机来使用。同时，还将获得高度灵活性，实现对容器的高效创建、部署及复制，并在环境之间迁移它们，从而有助于您针对云来优化应用。\nDocker 中的容器就像是轻量级的虚拟机，虽然不是真正模拟整个操作系统，但能提供类似的隔离运行环境。镜像就像是程序运行所需要的环境模板，容器就是在这个模板基础上启动起来的“活的”实例。\n系统服务 分析系统所需要的功能，将其模块化分别放入容器中。\n系统所需容器如下\nInference容器，用于推理图片中的垃圾属于什么类型 Flask容器 作为系统的核心服务，负责接收用户请求、调度任务 Mysql容器 用于存储系统数据，包括用户信息、识别结果、训练日志等 ffmpeg容器 用于摄像头推流 hls容器 视频流转码 frame-extractor 容器 用于抓取视频帧 rtsp容器 视频流中转（ffmpeg将视频流推送到rtsp服务器，系统从rtsp服务器获取视频流） ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/docker%E4%BD%BF%E7%94%A8/cover_hu9347038278956875274.jpg","permalink":"https://rxlxr11.github.io/p/docker%E4%BD%BF%E7%94%A8/","title":"Docker使用"},{"content":"Java Database Connectivity 概念 JAVA数据库连接技术\n主要功能 1.与数据库建立连接、执行SQL语句、处理结果\n相关对象功能 DriverManager: 管理JDBC驱动\nConnection: 负责数据库连接并传送数据任务\nStatement: 负责执行SQL语句\nResultSet: 负责保存结果（结果集）\n操作步骤 加载JDBC驱动 Class.forName(........); 建立与数据库连接 Connection con=DriverManager.getConnection(URL,数据库用户名,密码); \u0026#34;jdbc:mysql://localhost:3306/world?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone = GMT\u0026#34;,\u0026#34;xxxx\u0026#34;,\u0026#34;xxxx\u0026#34; 发送SQL语句得到结果集 Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(String sql); 释放资源 rs.close(); stmt.close(); con.close(); Statement常用方法 ResultSet executeQuery(String sql)//执行sql查询并获得结果集 int executeUpdate(String sql)//可以执行插入、删除、更新等操作，返回的是执行操作影响的行数 boolean execute(String sql)//执行任意sql语句，获得一个布尔值，表示是否返回ResultSet void close()//关闭 ResultSet boolean next()//将游标从当前位置向下移动一行 boolean previous()//游标从当前位置向上移动一行 void close()//关闭ResultSet 对象 int getInt(int colIndex)//以int形式获取结果集当前行指定列号值 int getInt(String colLabel)//以int形式获取结果集当前行指定列名值 float getFloat(int colIndex)//以float形式获取结果集当前行指定列号值 float getFloat(String colLabel)//以float形式获取结果集当前行指定列名值 String getString(int colIndex)//以String 形式获取结果集当前行指定列号值 String getString(String colLabel)//以String形式获取结果集当前行指定列名值 PreparedStatement 优点 1.提高代码的可读性与可维护性\n2.提高sql语句的执行性能\n3.提高了安全性\n举例 public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt = null; conn = DriverManager.getConnection( \u0026#34;jdbc:mysql://localhost:3306/epet\u0026#34;, \u0026#34;epetadmin\u0026#34;, \u0026#34;0000\u0026#34;); // 3、更新狗狗信息到数据库 String sql=\u0026#34;update dog set health=?,love=? where id=?\u0026#34;; pstmt = conn.prepareStatement(sql); pstmt.setInt(1, 80); pstmt.setInt(2, 15); pstmt.setInt(3, 1); pstmt.executeUpdate(); pstmt.setInt(1, 90); pstmt.setInt(2, 10); pstmt.setInt(3, 2); pstmt.executeUpdate(); logger.info(\u0026#34;成功更新狗狗信息！\u0026#34;); } catch (SQLException e) {\tlogger.error(e); } finally { // 4、关闭Statement和数据库连接 try { if (null != pstmt) { pstmt.close(); } if (null != conn) { conn.close(); } } catch (SQLException e) { logger.error(e); } } } ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/jdbc/cover_hu10934689398732408489.jpg","permalink":"https://rxlxr11.github.io/p/jdbc/","title":"JDBC"},{"content":"","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/jsp/cover_hu8208069686246646130.jpg","permalink":"https://rxlxr11.github.io/p/jsp/","title":"jsp"},{"content":"","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/yb-mvc/cover_hu1562122240878865747.jpg","permalink":"https://rxlxr11.github.io/p/yb-mvc/","title":"yb-mvc"},{"content":"","date":"2025-02-19T00:00:00Z","permalink":"https://rxlxr11.github.io/p/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","title":"常用指令"},{"content":"什么是B/S技术 c/s B/S架构（浏览器/服务器）： 程序完全部署在服务器上\nB/S技术的工作原理 B/S架构采用请求/响应模式进行交互\nURL Uniform Resource Locator统一资源定位符\n组成 http :// localhost:8080/ news/index.html\n协议部分 主机IP地址：端口号 项目资源地址\nTomcat 简介 Apache Jakarta的开源项目 JSP/Servlet容器\nTomcat服务器的目录结构 目录 说明 /bin 存放各种平台下用于启动和停止Tomcat的脚本文件 /conf 存放Tomcat服务器的各种配置文件 /lib 存放Tomcat服务器所需的各种JAR文件 /logs 存放Tomcat的日志文件 /temp Tomcat运行时用于存放临时文件 /webapps 当发布Web应用时，默认情况下会将Web应用的文件存放于此目录中 /work Tomcat把由JSP生成的Servlet放于此目录下 Tomcat的端口配置 通过配置文件server.xml修改Tomcat端口号‘’ \u0026lt;Connector port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; redirectPort=\u0026#34;8443 \u0026#34; /\u0026gt; Web应用的目录结构 目录 说明 / Web应用的根目录，该目录下所有文件在客户端都可以访问(JSP、HTML等) /WEB-INF 存放应用使用的各种资源，该目录及其子目录对客户端都是不可以访问 /WEB-INF/classes 存放Web项目的所有的class文件 /WEB-INF/lib 存放Web应用使用的JAR文件 创建、部署和发布项目 1.编写Web应用的代码\n2.在webapps目录下创建应用文件目录\n3.将创建的页面复制到应用目录下\n4.启动Tomcat服务并进行访问\n配置访问页面 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app version=\u0026#34;2.4\u0026#34; xmlns=\u0026#34;http://java.sun.com/xml/ns/j2ee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\u0026#34;\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt; IDEA项目结构介绍 project 项目信息\nmodule 模块信息\nLibrary 依赖信息\nFacet 每个模块使用技术的一些配置信息\nartifact 最终发布或者测试要用的综合产物\nJSP 简介 Java Server Pages\njsp乱码问题解决 将-Dfile.encoding=UTF-8分别放入idea的tomcat配置的vm options里，和idea的help选项的vm options配置文件里，然后重启idea\n-Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dfile.encoding=UTF-8 -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -Djdk.http.auth.tunneling.disabledSchemes=\u0026#34;\u0026#34; -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -javaagent:C:\\Users\\Public\\.jetbrains\\jetbrains-agent-v3.2.0.de72.619 JSP中的page指令 语法 \u0026lt;%@ page 属性1=\u0026#34;属性值\u0026#34; 属性2=\u0026#34;属性值1,属性值2\u0026#34;… 属性n=\u0026#34;属性值n\u0026#34;%\u0026gt; 常用属性\n属性 描述 默认值 language 指定JSP页面使用的脚本语言 java import 通过该属性来引用脚本语言中使用到的类文件 无 contentType 用来指定JSP页面所采用的编码方式 text/html, ISO-8859-1 out对象 out对象是JSP的内置对象 无需实例化即可使用\n实现数据的输出显示 out对象的方法 属性 说明 print 向页面输出显示 println 向页面输出显示，在结尾处添加换行 JSP中的小脚本与表达式 示例 \u0026lt;%@ page language=\u0026#34;java\u0026#34; import=\u0026#34;java.util.*,java.text.*\u0026#34; contentType=\u0026#34;text/html; charset=utf-8\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;计算求和\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 两个数的求和结果为： \u0026lt;% int numA = 4, numB = 5 ; int result = numA+numB; %\u0026gt; \u0026lt;%=result %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSP中的声明 语法 \u0026lt;%! Java代码%\u0026gt; 示例\n\u0026lt;%@ page language=\u0026#34;java\u0026#34; import=\u0026#34;java.util.*,java.text.*\u0026#34; contentType=\u0026#34;text/html; charset=utf-8\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;%！ String formatDate(Date d){ SimpleDateFormat formater = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日\u0026#34;); return formater.format(d); } %\u0026gt;你好，今天是 \u0026lt;%=formatDate(new Date()) %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSP中的注释 JSP注释 \u0026lt;%-- JSP注释--%\u0026gt; 在JSP脚本中注释 \u0026lt;% //单行注释 %\u0026gt; \u0026lt;% /*多行注释 */ %\u0026gt; 小结（JSP 页面元素） 元素 表达方式 小脚本 \u0026lt;%Java代码 %\u0026gt; 表达式 \u0026lt;%=Java表达式 %\u0026gt; 声明 \u0026lt;%! 方法 %\u0026gt; | 注释 | \u0026lt;%\u0026ndash; 客户端无法查看到 \u0026ndash;%\u0026gt; | | 指令 | 以“\u0026lt;%@ ” 开始，以“%\u0026gt; ” 结束 |\nJSP 执行过程 1.翻译阶段\n翻译代码举例\n/* * Generated by the Jasper component of Apache Tomcat * Version: Apache Tomcat/8.5.66 * Generated at: 2024-05-06 03:07:01 UTC * Note: The last modified time of this file was set to * the last modified time of the source file after * generation to assist with modification tracking. */ package org.apache.jsp; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.jsp.*; public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports { public String cc(){ return \u0026#34;cc\u0026#34;; } private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map\u0026lt;java.lang.String,java.lang.Long\u0026gt; _jspx_dependants; private static final java.util.Set\u0026lt;java.lang.String\u0026gt; _jspx_imports_packages; private static final java.util.Set\u0026lt;java.lang.String\u0026gt; _jspx_imports_classes; static { _jspx_imports_packages = new java.util.HashSet\u0026lt;\u0026gt;(); _jspx_imports_packages.add(\u0026#34;javax.servlet\u0026#34;); _jspx_imports_packages.add(\u0026#34;javax.servlet.http\u0026#34;); _jspx_imports_packages.add(\u0026#34;javax.servlet.jsp\u0026#34;); _jspx_imports_classes = null; } private volatile javax.el.ExpressionFactory _el_expressionfactory; private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map\u0026lt;java.lang.String,java.lang.Long\u0026gt; getDependants() { return _jspx_dependants; } public java.util.Set\u0026lt;java.lang.String\u0026gt; getPackageImports() { return _jspx_imports_packages; } public java.util.Set\u0026lt;java.lang.String\u0026gt; getClassImports() { return _jspx_imports_classes; } public javax.el.ExpressionFactory _jsp_getExpressionFactory() { if (_el_expressionfactory == null) { synchronized (this) { if (_el_expressionfactory == null) { _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); } } } return _el_expressionfactory; } public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() { if (_jsp_instancemanager == null) { synchronized (this) { if (_jsp_instancemanager == null) { _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); } } } return _jsp_instancemanager; } public void _jspInit() { } public void _jspDestroy() { } public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException { final java.lang.String _jspx_method = request.getMethod(); if (!\u0026#34;GET\u0026#34;.equals(_jspx_method) \u0026amp;\u0026amp; !\u0026#34;POST\u0026#34;.equals(_jspx_method) \u0026amp;\u0026amp; !\u0026#34;HEAD\u0026#34;.equals(_jspx_method) \u0026amp;\u0026amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) { response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, \u0026#34;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS\u0026#34;); return; } final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try { response.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;html\u0026gt;\\n\u0026#34;); out.write(\u0026#34; \u0026lt;head\u0026gt;\\n\u0026#34;); out.write(\u0026#34; \u0026lt;title\u0026gt;$Title$\u0026lt;/title\u0026gt;\\n\u0026#34;); out.write(\u0026#34; \u0026lt;/head\u0026gt;\\n\u0026#34;); out.write(\u0026#34; \u0026lt;body\u0026gt;\\n\u0026#34;); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34; \u0026#34;); out.print(\u0026#34;dsadas\u0026#34;); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34; \u0026#34;); int i = 10; out.print(i); out.write(\u0026#39;\\n\u0026#39;); out.write(\u0026#39; \u0026#39;); out.write(\u0026#39; \u0026#39;); out.write(\u0026#39;\\n\u0026#39;); out.write(\u0026#39; \u0026#39;); out.write(\u0026#39; \u0026#39;); out.print(cc() ); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34; $END$\\n\u0026#34;); out.write(\u0026#34; \u0026lt;/body\u0026gt;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;/html\u0026gt;\\n\u0026#34;); } catch (java.lang.Throwable t) { if (!(t instanceof javax.servlet.jsp.SkipPageException)){ out = _jspx_out; if (out != null \u0026amp;\u0026amp; out.getBufferSize() != 0) try { if (response.isCommitted()) { out.flush(); } else { out.clearBuffer(); } } catch (java.io.IOException e) {} if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); } } finally { _jspxFactory.releasePageContext(_jspx_page_context); } } } 2.编译阶段\n3.执行阶段\n修改jsp无需重启服务器\n集成开发工具创建Web项目 1.在idea中创建Web项目： create New Project\u0026ndash;\u0026gt;java\u0026ndash;\u0026gt;javaEE\u0026ndash;\u0026gt;web Application勾上，创建项目\n2.配置tomcat\n3.配置tomcat依赖\nProject Structure \u0026ndash;》modules\u0026ndash;》dependencies\u0026ndash;》+\u0026ndash;》library\u0026ndash;》tomcat依赖\n4.后面web项目加依赖，要在web-inf下面建lib文件夹，将jar包放入lib，再add as Library\n小贴士 request.getContextpath（）//相当于到webapp根路径 ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/cover_hu7770874312429586608.jpg","permalink":"https://rxlxr11.github.io/p/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","title":"动态网页开发基础"},{"content":"","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E8%BD%AE%E6%92%AD%E5%9B%BE/cover_hu13982268407473525903.jpg","permalink":"https://rxlxr11.github.io/p/%E8%BD%AE%E6%92%AD%E5%9B%BE/","title":"轮播图"},{"content":"DAO实现连接数据库 根据jdbc的基础知识可以看出，连接数据库的关键是要获取Connection对象，且数据库的连接数量存在限制，所以我们在一次连接中完成要做的业务后要关闭连接。为了提高代码的简洁性，复用性。我们要将获取connnection和关闭相关资源封装。\n根据以上信息我们可以创建一个IBaseDao接口，以后的dao都要继承IBaseDao\npublic interface IBaseDao { Connection getConnection(); void close(ResultSet resultSet, Statement statement, Connection connection); } 实现IBaseDao接口 加载配置文件 将驱动，url，用户名，密码直接写在java代码中属于硬编码，为了让代码更加通用，我们将上述信息写在配置文件中，在java代码中我们只需要加载配置文件即可获取对应的信息。\n创建配置文件 在resources文件夹下创建jdbc.properties\n注意没有引号，在jdbc示例代码中copy过来时要注意\ndriver = com.mysql.cj.jdbc.Driver url = jdbc:mysql://localhost:3306/数据库名?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT user = 用户名 password = 密码 类加载时加载配置文件 用静态代码块实现在类加载时获取配置信息\nprivate static String driver; private static String url; private static String user; private static String password; static { try { //新建一个properties对象 Properties properties = new Properties(); //通过路径名获取配置文件输入流 InputStream resourceAsStream = BaseDaoImpl.class.getResourceAsStream(\u0026#34;/jdbc.properties\u0026#34;); //加载配置问价 properties.load(resourceAsStream); //根据关键字获取属性 driver = properties.getProperty(\u0026#34;driver\u0026#34;); url = properties.getProperty(\u0026#34;url\u0026#34;); user = properties.getProperty(\u0026#34;user\u0026#34;); password = properties.getProperty(\u0026#34;password\u0026#34;); //加载驱动 Class.forName(driver); } catch (ClassNotFoundException | IOException e) { e.printStackTrace(); } } 实现getConnection方法 @Override public Connection getConnection() { Connection connection = null; try { connection = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return connection; } 实现close 应遵守先开的后关，后开先关的原则\n@Override public void close(ResultSet resultSet, Statement statement, Connection connection) { if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 根据表实现DAO 有以下表\n字段名 数据类型 约束条件 说明 student_id int NOT NULL AUTO_INCREMENT PRIMARY KEY 学生ID student_name varchar(255) DEFAULT NULL 学生姓名 student_age int DEFAULT NULL 学生年龄 student_gender int DEFAULT NULL 学生性别（可能使用 0/1 表示） student_idcard varchar(255) DEFAULT NULL 学生身份证号 student_num varchar(255) DEFAULT NULL 学生学号 student_phone varchar(255) DEFAULT NULL 学生电话 class_id int DEFAULT NULL 班级ID，外键关联班级表 实体类 public class Student { private Integer studentId; private String studentName; private Integer age; private Integer gender; private String studentIdcard; private String studentNum; private String studentPhone; public Student(Integer studentId, String studentName, Integer age, Integer gender, String studentIdcard, String studentNum, String studentPhone) { this.studentId = studentId; this.studentName = studentName; this.age = age; this.gender = gender; this.studentIdcard = studentIdcard; this.studentNum = studentNum; this.studentPhone = studentPhone; } public Student() { } public Integer getStudentId() { return studentId; } public void setStudentId(Integer studentId) { this.studentId = studentId; } public String getStudentName() { return studentName; } public void setStudentName(String studentName) { this.studentName = studentName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public String getStudentIdcard() { return studentIdcard; } public void setStudentIdcard(String studentIdcard) { this.studentIdcard = studentIdcard; } public String getStudentNum() { return studentNum; } public void setStudentNum(String studentNum) { this.studentNum = studentNum; } public String getStudentPhone() { return studentPhone; } public void setStudentPhone(String studentPhone) { this.studentPhone = studentPhone; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return Objects.equals(studentId, student.studentId) \u0026amp;\u0026amp; Objects.equals(studentName, student.studentName) \u0026amp;\u0026amp; Objects.equals(age, student.age) \u0026amp;\u0026amp; Objects.equals(gender, student.gender) \u0026amp;\u0026amp; Objects.equals(studentIdcard, student.studentIdcard) \u0026amp;\u0026amp; Objects.equals(studentNum, student.studentNum) \u0026amp;\u0026amp; Objects.equals(studentPhone, student.studentPhone); } @Override public int hashCode() { return Objects.hash(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone); } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;studentId=\u0026#34; + studentId + \u0026#34;, studentName=\u0026#39;\u0026#34; + studentName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, studentIdcard=\u0026#39;\u0026#34; + studentIdcard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, studentNum=\u0026#39;\u0026#34; + studentNum + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, studentPhone=\u0026#39;\u0026#34; + studentPhone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 新建接口 public interface IStudentDao extends IBaseDao { ArrayList\u0026lt;Student\u0026gt; queryAll(); } 实现接口 继承BaseDao并实现IStudentDao\npublic class StudentDaoImpl extends BaseDaoImpl implements IStudentDao { @Override public ArrayList\u0026lt;Student\u0026gt; queryAll() { //建立数据库连接 Connection con = getConnection(); PreparedStatement statement = null; ResultSet resultSet=null; ArrayList\u0026lt;Student\u0026gt; students=null; try { //执行sql语句并返回结果 statement = con.prepareStatement(\u0026#34;select * from student\u0026#34;); resultSet = statement.executeQuery(); students= new ArrayList\u0026lt;\u0026gt;(); //通过集合将结果集映射到集合 while (resultSet.next()){ String studentName = resultSet.getString(\u0026#34;student_name\u0026#34;); Integer studentId = resultSet.getInt(\u0026#34;student_id\u0026#34;); Integer age = resultSet.getInt(\u0026#34;student_age\u0026#34;); Integer gender = resultSet.getInt(\u0026#34;student_gender\u0026#34;); String studentIdcard = resultSet.getString(\u0026#34;student_idcard\u0026#34;); String studentNum = resultSet.getString(\u0026#34;student_num\u0026#34;); String studentPhone = resultSet.getString(\u0026#34;student_phone\u0026#34;); Student student = new Student(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone); students.add(student); } } catch (SQLException e) { e.printStackTrace(); }finally { close(resultSet,statement,con); } return students; } } 测试 目录结构 main └── java └── com.rxlxr ├── dao │ ├── impl │ │ ├── BaseDaoImpl │ │ └── StudentDaoImpl │ ├── IBaseDao │ └── IStudentDao ├── pojo │ └── Student └── Test └── resources └── jdbc.properties 测试代码 public class Test { public static void main(String[] args) { StudentDaoImpl studentDao = new StudentDaoImpl(); ArrayList\u0026lt;Student\u0026gt; students = studentDao.queryAll(); System.out.println(students); } } 测试结果 [Student{studentId=1, studentName=\u0026#39;aa\u0026#39;, age=11, gender=11, studentIdcard=\u0026#39;11\u0026#39;, studentNum=\u0026#39;11\u0026#39;, studentPhone=\u0026#39;11\u0026#39;}] 结论 根据表结构新建pojo类 写IBaseDao（ getConnecion(), DriverManager close(ResultSet resultSet, Statement statement, Connection connection)） 实现IBaseDao 私有属性（driver，url, user,password） 加载properties，ClassLoader 根据键值赋值 加载驱动 Class.forName 写 Dao 接口 继承 IBaseDao ArrayList queryAll(); Integer addOne(E e); Integer updateById(E e); Integer deleteById(Integer id); queryById(Integer id) queryByCondition(User user) 实现Dao 继承 IBaseDaoImpl //1. get connection Connection connection = getConnection(); //2. declare statement resultSet Statement statement = null; ResultSet resultSet = null; //3. declare return //4. exe try{ //4.1 string sql //4.2 赋值 statement // 4.3 resultSet(if have) //4.4 赋值 return }catch(){ }finally{ //5. close close(resultSet,statement,connection); } // 6. return ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0dao/cover_hu4604435891129706629.jpg","permalink":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0dao/","title":"用JDBC实现DAO"},{"content":"增删改查 基于用jdbc实现DAO，在对应实体类的DAO中，增加相应声明。\npublic interface IStudentDao extends IBaseDao { ArrayList\u0026lt;Student\u0026gt; queryAll(); Integer addOne(Student student); Integer updateById(Student student); Integer deleteById(Integer studentId); Student queryById(Integer id); ArrayList\u0026lt;Student\u0026gt; queryByCondition(Student student); } 增 @Override public Integer addOne(Student student) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { //写要执行的sql语句 statement = con.prepareStatement(\u0026#34;insert into student values (default,?,?,?,?,?,?)\u0026#34;); //根据下标设置参数，下标从1开始 statement.setString(1,student.getStudentName()); statement.setInt(2,student.getAge()); statement.setInt(3,student.getGender()); statement.setString(4,student.getStudentIdcard()); statement.setString(5,student.getStudentNum()); statement.setString(6,student.getStudentPhone()); //返回修改了几条记录 i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 删 删和改一定要有where\n@Override public Integer deleteById(Integer studentId) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { statement = con.prepareStatement(\u0026#34;delete from student where student_id=?\u0026#34;); statement.setInt(1,studentId); i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 改 @Override public Integer updateById(Student student) { Connection con = getConnection(); PreparedStatement statement = null; Integer i = 0; try { statement = con.prepareStatement(\u0026#34;update student set student_name=?,student_age=?,student_gender=?,student_idcard=?,student_num=?,student_phone=? where student_id = ?\u0026#34; ); statement.setString(1,student.getStudentName()); statement.setInt(2,student.getAge()); statement.setInt(3,student.getGender()); statement.setString(4,student.getStudentIdcard()); statement.setString(5,student.getStudentNum()); statement.setString(6,student.getStudentPhone()); statement.setInt(7,student.getStudentId()); i = statement.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { close(null,statement,con); } return i; } 查 根据条件查询，传入的对象中的值即为条件\n注意点\n不清楚有几个条件，要计算and的数量，以及是否需要where \u0026lsquo;?\u0026lsquo;与value要正确对应 @Override public ArrayList\u0026lt;Student\u0026gt; queryByCondition(Student student) { Connection connection = getConnection(); PreparedStatement statement = null; ResultSet resultSet = null; ArrayList\u0026lt;Student\u0026gt; students = null; // 用于存储下标和？的值 ArrayList\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); try { students = new ArrayList\u0026lt;\u0026gt;(); StringBuilder stringBuilder = new StringBuilder(); String sql = \u0026#34;select * from student\u0026#34;; boolean flag = false; if (student.getStudentName() != null) { flag = true; objects.add(student.getStudentName()); stringBuilder.append(\u0026#34; student_name=? and\u0026#34;); } if (student.getAge() != null) { flag = true; objects.add(student.getAge()); stringBuilder.append(\u0026#34; student_age=? and\u0026#34;); } if (student.getGender() != null) { flag = true; objects.add(student.getGender()); stringBuilder.append(\u0026#34; student_gender=? and\u0026#34;); } if (student.getStudentIdcard() != null) { flag = true; objects.add(student.getStudentIdcard()); stringBuilder.append(\u0026#34; student_idcard=? and\u0026#34;); } if (student.getStudentNum() != null) { flag = true; objects.add(student.getStudentNum()); stringBuilder.append(\u0026#34; student_num=? and\u0026#34;); } if (student.getStudentPhone() != null) { flag = true; objects.add(student.getStudentPhone()); stringBuilder.append(\u0026#34; student_phone=? and\u0026#34;); } String string = stringBuilder.toString(); String substring=\u0026#34;\u0026#34;; String whereStr = \u0026#34;\u0026#34;; if (flag){ string = string.substring(0,string.length()-3); whereStr = \u0026#34; where \u0026#34;; } //拼接sql sql = flag ? sql+whereStr+string : sql; statement = connection.prepareStatement(sql); for (int i = 0; i \u0026lt; objects.size(); i++) { statement.setObject(i+1,objects.get(i)); } resultSet = statement.executeQuery(); while (resultSet.next()){ String studentName = resultSet.getString(\u0026#34;student_name\u0026#34;); Integer studentId = resultSet.getInt(\u0026#34;student_id\u0026#34;); Integer age = resultSet.getInt(\u0026#34;student_age\u0026#34;); Integer gender = resultSet.getInt(\u0026#34;student_gender\u0026#34;); String studentIdcard = resultSet.getString(\u0026#34;student_idcard\u0026#34;); String studentNum = resultSet.getString(\u0026#34;student_num\u0026#34;); String studentPhone = resultSet.getString(\u0026#34;student_phone\u0026#34;); students.add(new Student(studentId, studentName, age, gender, studentIdcard, studentNum, studentPhone)); } } catch (SQLException e) { e.printStackTrace(); } finally { close(resultSet,statement,connection); } return students; } ","date":"2025-02-19T00:00:00Z","image":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/cover_hu2153556584596572680.jpg","permalink":"https://rxlxr11.github.io/p/%E7%94%A8jdbc%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","title":"用JDBC实现增删改查"},{"content":"搭建 美化 mac风格代码块 在 assets/scss/partials/layout/article.scss，找到 .highlight 部分并修改成如下：\n.highlight { background-color: var(--pre-background-color); padding: var(--card-padding); position: relative; border-radius: 10px; max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; 创建 static/img/code-header.svg 文件：\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;450px\u0026#34; height=\u0026#34;130px\u0026#34;\u0026gt; \u0026lt;ellipse cx=\u0026#34;65\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(220,60,54)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(237,108,96)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;225\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(218,151,33)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(247,193,81)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;385\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(27,161,37)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(100,200,86)\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; 最后在 assets/scss/custom.scss 添加代码块的样式：\n// 为代码块顶部添加 macos 样式 .article-content { .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(/img/code-header.svg); height: 25px; width: 100%; background-size: 52px; background-repeat: no-repeat; margin-top: -10px; margin-bottom: 0; } } 短评卡片 详情见Hugo Stack 主题装修笔记 Part 3\n龙族Ⅰ 2025 年 06 月 19 日 读过 他以为他将这样度过一生，他以为他始终只是个衰小孩。但是，一封来自卡塞尔学院的录取通知书改变了他的一生。云层里透出神秘的吟唱：你也有神奇的父母，你也有热血的同伴，你的血管里流动着龙族的血液。而你的目标将是 —— 屠龙。 book 返回顶部 详情见返回顶部\n折叠 使用方法如下,使用时去掉反斜杠\n{\\{\u0026lt; details title=\u0026#34;Learn More\u0026#34; \u0026gt;}\\} Collapsed text {\\{\u0026lt; /details \u0026gt;}\\} Learn More public static person 归档副标题 在assets/scss/partials/article.scss里找到.article-list--compact，在里面添加如下css设置：\n.article-subtitle { margin-top: -5px; font-size: 1.5rem; @include respond(md) { font-size: 1.6rem; } } Copy\n再在layouts/partials/article-list/compact.html添加如下代码：\n\u0026lt;h2 class=\u0026#34;article-title\u0026#34;\u0026gt; {{- .Title -}} \u0026lt;/h2\u0026gt; {{ with .Params.description }} \u0026lt;div class=\u0026#34;article-subtitle\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} 标题样式 在assets/scss/custom.scss文件中修改\n原本代码\nh1, h2, h3, h4, h5, h6 { margin-inline-start: calc((var(--card-padding)) * -1); padding-inline-start: calc(var(--card-padding) - var(--heading-border-size)); border-inline-start: var(--heading-border-size) solid var(--accent-color); position: relative; a.header-anchor { transition: opacity 0.3s ease; opacity: 0; position: absolute; left: 0; width: var(--card-padding); text-align: center; color: var(--accent-color); \u0026amp;:before { content: \u0026#34;#\u0026#34;; } } \u0026amp;:hover, \u0026amp;:focus { a.header-anchor { opacity: 1; } } } 修改后代码\nh1, h2, h3, h4, h5, h6 { position: relative; font-weight: bold; margin: 12px auto 2px !important; letter-spacing: 2px; padding-inline-start: calc(var(--card-padding) - var(--heading-border-size)); } /* 标题向右略微偏移，缩小距离 */ h1 { left: 0.6em; } h2 { left: 1em; } h3 { left: 1.4em; } h4 { left: 1.8em; } h5 { left: 2.2em; } h6 { left: 2.6em; } /* 井号的位置也稍微向右移一点点 */ h1::before { content: \u0026#34;#\u0026#34;; color: #42b98390; position: absolute; left: -0.6em; } h2::before { content: \u0026#34;##\u0026#34;; color: #42b98390; position: absolute; left: -1em; } h3::before { content: \u0026#34;###\u0026#34;; color: #42b98390; position: absolute; left: -1.4em; } h4::before { content: \u0026#34;####\u0026#34;; color: #42b98390; position: absolute; left: -1.8em; } h5::before { content: \u0026#34;#####\u0026#34;; color: #42b98390; position: absolute; left: -2.2em; } h6::before { content: \u0026#34;######\u0026#34;; color: #42b98390; position: absolute; left: -2.6em; } 外链提示 在layouts/_default/_markup/render-link.html里{{ .Text | safeHTML }}之后增加如下代码\n{{ if strings.HasPrefix .Destination \u0026#34;http\u0026#34; }} \u0026lt;span style=\u0026#34;white-space: nowrap;\u0026#34;\u0026gt;\u0026lt;svg width=\u0026#34;.7em\u0026#34; height=\u0026#34;.7em\u0026#34; viewBox=\u0026#34;0 0 21 21\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z\u0026#34; fill=\u0026#34;currentColor\u0026#34; /\u0026gt; \u0026lt;path d=\u0026#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;/svg\u0026gt;\u0026lt;/span\u0026gt; {{ end }} 分类颜色 详情见\n热力图 图片轮播 固定块高度 相册 https://yelleis.top/about/ https://thirdshire.com/ https://hyrtee.github.io/2023/start-blog/\n","date":"2025-02-18T00:00:00Z","image":"https://rxlxr11.github.io/p/hugo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/cover_hu93032716579575849.jpg","permalink":"https://rxlxr11.github.io/p/hugo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo 搭建博客"},{"content":"通用 柱状图 折线图 ","date":"2025-01-05T00:00:00Z","image":"https://rxlxr11.github.io/p/echarts-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/cover_hu2225790436479499727.jpg","permalink":"https://rxlxr11.github.io/p/echarts-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"Echarts 使用技巧"},{"content":"三大特性 IOC（Inversion of Control） 在以往的开发中，一个类若想调用另一个类的属性或方法，通常会使用new Object()的方式来实现调用，将前者称为调用者后者成为被调用者，这样就可以说是调用者掌握着被调用者对象创建的控制权。ioc带来的不仅仅是代码层次的改变，而是思想方面发生了”主从换位“的改变。原本调用者要想使用哪些资源都会主动出击，自己创建。但在spring应用中，ioc掌握着主动权，调用者变成了被动的一方，被动的等待ioc创建他所需要的对象，这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给ioc容器来帮忙实现，因此，将这个过程称为spring的控制反转。\nDI 依赖注入，控制反转的核心思想就是由spring来负责对象的创建，在创建对象的过程中，spring会自动根据依赖关系将他依赖的对象注入到当前对象中，这就是依赖注入，依赖注入本质上是spring bean属性注入的一种，只不过这个属性是一个对象属性而已。属性注入的方式有①set方式②有参构造③p命名空间\nAOP 面向切面编程\n","date":"2025-01-05T00:00:00Z","image":"https://rxlxr11.github.io/p/springboot/cover_hu2225790436479499727.jpg","permalink":"https://rxlxr11.github.io/p/springboot/","title":"springboot"},{"content":"变量的命名的规则：字下美人数 \u0026ndash;字母下划线 美元的符号人民币符号数字 首字母小写，驼峰（第二个及以后的单词的首字母大写）表示 首字母只允许使用字母下划线和美元符号\n常量：被常量关键字final修饰的变量为常量，特点只能赋值一次，并且变量名要全部大写\n如何建一个较完整的类 私有化属性 对外提供特定公共的访问或者修改方法 创建无参构造函数 创建全参构造函数 重写toString（）方法 重写equals()和hashCode（）方法 包的命名规范 小写 域名倒置\n普通代码块是对象创建时候执行 静态代码块是类加载的时候执行\n五个常见异常：：ClassCastException（类转换异常）、IndexOutOfBoundsException（数组越界）、NullPointerException（空指针异常）、IllegalAccessException（安全权限异常）及IOException（输入输出异常）\n同步：线程之前互相等待锁释放 异步：线程之前互不干涉\nCollection 接口存储一组不唯一，无序的对象 List存储一组不唯一，有序（插入顺序）的对象 set存储一组唯一，无序的对象 Map接口存储一组键值对象，提供key到value的映射\n三大范式 第一范式的目标是确保每列的原子性 第二范式要求每个表只描述一件事情 第三范式如果一个关系满足2NF，并且除了主键以外的其他列都不传递依赖于主键列\nspring\n控制反转（Inversion of Control\u0026mdash;IOC）\n是一种设计思想，人话：将对象交给容器去管理，例如不需要你去new象了，由容器去创建对象提供给你。\n依赖注入（Dependency Injection\u0026mdash;DI）\n就是你写的类在运行的时候依赖于ioc容器在你需要某个对象的时候给你去注入对象\n面向切面（Aspect Oriented Programming\u0026mdash;AOP）\n面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n","date":"2025-01-05T00:00:00Z","permalink":"https://rxlxr11.github.io/p/%E5%9F%BA%E6%9C%AC%E7%B4%A0%E5%85%BB/","title":"基本素养"}]